When we were originally designing the language, we focused on the application first. We saw the boilerplate code and network protocol knowledge required to write networked applications as barriers to new developers and unnecessary pain points for experienced web developers. The objective was to come up with an expressive way for clients and servers to talk without really having to talk about clients and servers very much. Of course we wanted our language to be expressive, compact, and reasonably easy to learn, but the underlying goal was to take the network out of networking so that application developers could focus on the logic.
In the spirit of AWK, we decided early on that we did not want to create a compiler for a general purpose language but rather an extremely targeted tool where the language is the interface for that tool. Originally, we had wanted to keep the compiled code completely hidden from the user. However, due to the dynamic nature of our language (and the facts of compiling to a dynamic language), compile-time semantic analysis is not foolproof. Errors may be thrown by the Node.js interpreter at runtime. In the case of these errors, line numbers and diagnostic messages reference the compiled JavaScript.
With this in mind, the Pass compiler places a compiled version of the program in the same directory as the original Pass source code. That said, the compiled version of any nontrivial Pass program is not functional without the Pass executable because it contains none of the server code. Instead, compiled Pass programs are readable JS modules which by and large reflect only the logic present in the original Pass source. This was a compromise achieved by some clever JavaScript meta-programming in the Pass executable that re-binds the scope of functions in the module, inserting various.
In terms of actual language constructs, we were adamant about sticking to our original minimalist principles. Every example from the tutorial and language reference manual will still compile and run. Moreover, we feel we have preserved the spirit of the language. Pass was always about abstracting network induced delay with the use of asynchronous callback functions, building on the foundation layed by JavaScript in this arena. This is still the main focus of the language. Any tradeoffs that were made were made in favor of developer productivity, rather than computational speed.
There is a single significant change to the language which stands out. Namely, the treatment of boolean values was changed to accommodate additional "falsy" values in the implementation language. In JavaScript, null, undefined, and the empty string will evaluate to false as well as our original singularly false 0. We feel that while this is a slight complication, it actually adds expressiveness to the language because the programmer may check if a dictionary key is defined with a straightforward boolean.
While we did not make significant changes to the core language, the standard library functions were refined and improved as we began to build applications in Pass. For instance, we added a feature to our mechanism for tagging that allows the programmer to specify that a user should only have a single tag. This feature was suggested by boilerplate code we were writing when creating a multi-room chat server. We sought to add features that were specific enough to abstract pain from the language but that were general enough to be useful for many different type of applications. This type of iterative improvement of the standard library was one of the most valuable in making the language pragmatic for our domain. 
The Pass compiler uses Antlr for the front-end and a custom built tree walker for the backend. We use Antlr to tokenize and parse the source program according to our grammar as well as for semantic analysis and construction of an AST. Antlr was a wonderfully flexible tool. However, if we were to re-implement the Pass compiler, we might use a slightly more modular approach. Additionally, the reimplementation would no doubt be in JavaScript to minimize dependencies.